@page "/form-template"
@using FlowManager.Shared.DTOs.Requests.Component
@using FlowManager.Shared.DTOs.Requests.FormTemplate
@using FlowManager.Shared.DTOs.Responses.Component
@using FlowManager.Shared.DTOs.Responses.FormTemplate
@using FlowManager.Client.ViewModels
@using FlowManager.Client.Services
@using FlowManager.Client.DTOs
@using static MudBlazor.CategoryTypes
@using FlowManager.Client.Services
@using System.Text.Json

<PageTitle>Form Template Builder</PageTitle>

<div class="form-template-container">
    <div class="form-template-header">
        <h1>Form Template Builder</h1>
        <div class="template-actions">
            <input @bind="templateName"
                   placeholder="Enter template name..."
                   class="template-name-input" />
            <button class="save-button"
                    @onclick="SaveTemplate"
                    disabled="@isSaving">
                @if (isSaving)
                {
                    <span class="loading-spinner"></span>
                }
                Save Template
            </button>
        </div>
    </div>

    <div class="form-template-content">
        <!-- Free Canvas - Left Side -->
        <div class="free-canvas"
             @onclick="OnCanvasClick"
             @ondrop="@OnDrop"
             @ondragover="@OnDragOver"
             @ondragover:preventDefault="true"
             @ref="canvasRef">

            <div class="canvas-header">
                <h2>Form Builder</h2>
                <div class="canvas-info">
                    <span class="element-count">@canvasElements.Count elements</span>
                </div>
            </div>

            <div class="canvas-workspace"
                 @onclick="OnWorkspaceClick"
                 @onmousemove="OnMouseMove"
                 @onmouseup="OnMouseUp">
                @if (!canvasElements.Any())
                {
                    <div class="empty-workspace">
                        <div class="empty-icon">📋</div>
                        <h3>Click anywhere to start writing</h3>
                        <p>Or drag components from the sidebar</p>
                    </div>
                }

                <!-- Render all canvas elements -->
                @foreach (var element in canvasElements)
                {
                    <div class="canvas-element @(element.IsTextElement ? "text-element" : "component-element")"
                         style="position: absolute; left: @(element.X)px; top: @(element.Y)px; z-index: @(element.ZIndex);"
                         @onmousedown="@((e) => OnElementMouseDown(e, element.Id))"
                         @onclick:stopPropagation="true">

                        @if (element.IsTextElement)
                        {
                            @if (isEditingText && editingElementId == element.Id)
                            {
                                <!-- Inline text editor -->
                                <div class="inline-text-editor" style="min-width: 200px;">
                                    <textarea @bind="editingText"
                                              @onblur="SaveTextEdit"
                                              @onkeydown="@((e) => HandleTextKeyDown(e))"
                                              class="inline-textarea"
                                              placeholder="Type here..."
                                              @ref="textareaRef"
                                              style="width: auto; min-width: 200px; height: auto;"></textarea>
                                </div>
                            }
                            else
                            {
                                <!-- Text display -->
                                <div class="text-display" @onclick="@(() => EditTextElement(element.Id))" @onmousedown:stopPropagation="false">
                                    @if (string.IsNullOrWhiteSpace(element.TextContent))
                                    {
                                        <span class="placeholder-text">Click to edit...</span>
                                    }
                                    else
                                    {
                                        @((MarkupString)element.TextContent.Replace("\n", "<br>"))
                                    }
                                    <button class="delete-element-btn" @onclick="@(() => RemoveElement(element.Id))" @onclick:stopPropagation="true">×</button>
                                </div>
                            }
                        }
                        else
                        {
                            <!-- Component display -->
                            <div class="component-display" @onmousedown:stopPropagation="false">
                                @if (element.ComponentType == "TextInput" || element.ComponentType == "email" || element.ComponentType == "text")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <input type="text" class="field-input" placeholder="@element.Label" readonly />
                                    </div>
                                }
                                @if (element.ComponentType == "Checkbox" || element.ComponentType == "checkbox")
                                {
                                    <div class="form-field">
                                        <label class="checkbox-field">
                                            <input type="checkbox" disabled />
                                            <span class="checkbox-label">
                                                @element.Label
                                                @if (element.Required == true)
                                                {
                                                    <span class="required-mark">*</span>
                                                }
                                            </span>
                                        </label>
                                    </div>
                                }
                                @if (element.ComponentType == "DateTime" || element.ComponentType == "date")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <input type="date" class="field-input" readonly />
                                    </div>
                                }
                                @if (element.ComponentType == "RadioButton" || element.ComponentType == "radio")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <div class="radio-group">
                                            <label class="radio-option">
                                                <input type="radio" name="radio_@element.Id" disabled />
                                                <span>Option 1</span>
                                            </label>
                                            <label class="radio-option">
                                                <input type="radio" name="radio_@element.Id" disabled />
                                                <span>Option 2</span>
                                            </label>
                                        </div>
                                    </div>
                                }
                                @if (element.ComponentType == "number")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <input type="number" class="field-input" placeholder="@element.Label" readonly />
                                    </div>
                                }
                                @if (element.ComponentType == "textarea")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <textarea class="field-input textarea-input" placeholder="@element.Label" readonly></textarea>
                                    </div>
                                }
                                @if (element.ComponentType == "select")
                                {
                                    <div class="form-field">
                                        <label class="field-label">
                                            @element.Label
                                            @if (element.Required == true)
                                            {
                                                <span class="required-mark">*</span>
                                            }
                                        </label>
                                        <select class="field-input" disabled>
                                            <option>Select an option</option>
                                            <option>Option 1</option>
                                            <option>Option 2</option>
                                        </select>
                                    </div>
                                }

                                <button class="delete-element-btn" @onclick="@(() => RemoveElement(element.Id))" @onclick:stopPropagation="true">×</button>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>

        <!-- Available Components - Right Side -->
        <div class="components-palette">
            <div class="palette-header">
                <h2>Available Components</h2>
                <span class="component-count">@availableComponents.Count available</span>
            </div>

            <div class="component-list">
                @if (isLoading)
                {
                    <div class="loading-state">
                        <p>Loading components...</p>
                        <div class="loading-spinner"></div>
                    </div>
                }
                else if (!availableComponents.Any())
                {
                    <div class="no-components">
                        <p>No components found</p>
                        <p>Status: @apiCallStatus</p>
                    </div>
                }
                else
                {
                    @foreach (var component in availableComponents)
                    {
                        <div class="component-item"
                             draggable="true"
                             @ondragstart="@(() => OnDragStart(component))">
                            <div class="component-icon">
                                @GetComponentIcon(component.Type)
                            </div>
                            <div class="component-info">
                                <div class="component-name">@component.Label</div>
                                <div class="component-type">@component.Type</div>
                            </div>
                            <div class="drag-handle">⋮⋮</div>
                        </div>
                    }
                }
            </div>

            <div class="palette-footer">
                <button class="add-component-btn" @onclick="AddNewComponent" @onclick:stopPropagation="true">
                    <span class="add-icon">+</span>
                    New Component
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Add Component Modal -->
@if (showAddComponentModal)
{
    <div class="modal-overlay" @onclick="CloseAddComponentModal" @onclick:stopPropagation="false">
        <div class="modal-container" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h2>Add New Component</h2>
                <button class="modal-close" @onclick="CloseAddComponentModal" @onclick:stopPropagation="true">×</button>
            </div>

            <div class="modal-content">
                <div class="modal-field">
                    <label class="modal-label">Component Type</label>
                    <select @bind="newComponent.Type" class="modal-select">
                        <option value="TextInput">Text Input</option>
                        <option value="Checkbox">Checkbox</option>
                        <option value="DateTime">Date Time</option>
                        <option value="RadioButton">Radio Button</option>
                        <option value="number">Number</option>
                        <option value="textarea">Text Area</option>
                        <option value="select">Select</option>
                    </select>
                </div>

                <div class="modal-field">
                    <label class="modal-label">Label</label>
                    <input @bind="newComponent.Label"
                           class="modal-input"
                           placeholder="Enter component label" />
                </div>

                <div class="modal-field">
                    <label class="checkbox-container">
                        <input @bind="newComponent.Required" type="checkbox" />
                        <span class="checkbox-mark">Required field</span>
                    </label>
                </div>

                @if (newComponent.Type == "TextInput")
                {
                    <div class="modal-field">
                        <label class="modal-label">Maximum Length</label>
                        <input @bind="newComponentMaxLength"
                               class="modal-input"
                               type="number"
                               min="0"
                               placeholder="0 = unlimited" />
                    </div>
                }
            </div>

            <div class="modal-footer">
                <button class="modal-btn secondary" @onclick="CloseAddComponentModal" @onclick:stopPropagation="true">
                    Cancel
                </button>
                <button class="modal-btn primary" @onclick="SaveNewComponent" @onclick:stopPropagation="true">
                    Add Component
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public EventCallback<(Guid Id, string Name)> OnTemplateSaved { get; set; }
    [Parameter] public bool ShouldSaveToDatabase { get; set; } = false;
    [Inject] private ComponentService ComponentService { get; set; } = default!;
    [Inject] private FormTemplateService FormTemplateService { get; set; } = default!;
    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;

    // Properties
    private List<ComponentResponseDto> availableComponents = new();
    private List<CanvasElement> canvasElements = new();
    private ComponentResponseDto? draggedComponent;
    private string templateName = "";
    private bool isSaving = false;
    private bool isLoading = true;

    // Modal state
    private bool showAddComponentModal = false;
    private PostComponentRequestDto newComponent = new();
    private int newComponentMaxLength = 0;

    // Text editing state
    private bool isEditingText = false;
    private string editingText = "";
    private Guid? editingElementId = null;

    // Canvas interaction
    private ElementReference canvasRef;
    private ElementReference textareaRef;

    // Drag state
    private bool isDragging = false;
    private Guid? draggedElementId = null;
    private double dragOffsetX = 0;
    private double dragOffsetY = 0;
    private bool justFinishedDragging = false;
    // Grid settings
    private const int GRID_SIZE = 25; // 20px for element + 5px spacing

    // Debug pentru API call
    private string apiCallStatus = "Not started";



    // Z-index counter for layering
    private int zIndexCounter = 1;

    // Canvas element model
    public class CanvasElement
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public double X { get; set; }
        public double Y { get; set; }
        public int ZIndex { get; set; }
        public bool IsTextElement { get; set; }

        // For text elements
        public string? TextContent { get; set; }

        // For components
        public Guid? ComponentId { get; set; }
        public string? ComponentType { get; set; }
        public string? Label { get; set; }
        public bool? Required { get; set; }
        public Dictionary<string, object>? Properties { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadAvailableComponents();
    }

    private async Task LoadAvailableComponents()
    {
        try
        {
            isLoading = true;
            apiCallStatus = "Starting API call...";
            StateHasChanged();

            var result = await ComponentService.GetAllComponentsQueriedAsync(new QueriedComponentRequestDto());

            if (result?.Data != null)
            {
                availableComponents = result.Data.ToList();
                apiCallStatus = $"Successfully loaded {availableComponents.Count} components from database";
            }
            else
            {
                apiCallStatus = "No data returned from API - check if backend is running";
                availableComponents = new List<ComponentResponseDto>();
            }
        }
        catch (Exception ex)
        {
            apiCallStatus = $"Error loading components: {ex.Message}";
            availableComponents = new List<ComponentResponseDto>();
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnWorkspaceClick(MouseEventArgs e)
    {
        if (justFinishedDragging)
        {
            justFinishedDragging = false;
            return; // Nu crea text element
        }

        // Only create text if not dragging and not editing
        if (!isDragging && !isEditingText)
        {
            try
            {
                // Snap to grid
                var gridX = SnapToGrid(e.OffsetX);
                var gridY = SnapToGrid(e.OffsetY - 60); // Subtract header height

                // Create text element at click position
                await CreateTextElement(gridX, gridY);
            }
            catch (Exception ex)
            {
                // Fallback to basic positioning
                await CreateTextElement(SnapToGrid(100), SnapToGrid(100));
            }
        }

    }

    private async Task OnElementMouseDown(MouseEventArgs e, Guid elementId)
    {
        // Don't start dragging if we're editing text
        if (isEditingText && editingElementId == elementId)
        {
            return;
        }

        // Start dragging
        isDragging = true;
        draggedElementId = elementId;

        // Calculate offset from element origin
        var element = canvasElements.FirstOrDefault(el => el.Id == elementId);
        if (element != null)
        {
            dragOffsetX = e.OffsetX;
            dragOffsetY = e.OffsetY;
        }
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (isDragging && draggedElementId.HasValue)
        {
            var element = canvasElements.FirstOrDefault(el => el.Id == draggedElementId.Value);
            if (element != null)
            {
                // Calculate new position relative to workspace
                var newX = e.OffsetX - dragOffsetX;
                var newY = e.OffsetY - dragOffsetY - 60; // Subtract header height

                // Snap to grid
                element.X = SnapToGrid(newX);
                element.Y = SnapToGrid(newY);

                StateHasChanged();
            }
        }
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (isDragging)
        {
            justFinishedDragging = true; // Marchează că tocmai am terminat de tras

            // Resetează după un delay scurt pentru a permite event-ului click să se proceseze
            _ = Task.Delay(100).ContinueWith(_ =>
            {
                justFinishedDragging = false;
                InvokeAsync(StateHasChanged);
            });
        }

        isDragging = false;
        draggedElementId = null;
        dragOffsetX = 0;
        dragOffsetY = 0;
    }

    private double SnapToGrid(double value)
    {
        return Math.Round(value / GRID_SIZE) * GRID_SIZE;
    }

    private async Task OnCanvasClick(MouseEventArgs e)
    {
        // This handles clicks on the canvas container, but we want workspace clicks
    }

    private async Task CreateTextElement(double x, double y)
    {
        var textElement = new CanvasElement
        {
            X = x,
            Y = y,
            ZIndex = ++zIndexCounter,
            IsTextElement = true,
            TextContent = ""
        };

        canvasElements.Add(textElement);

        // Start editing immediately
        await EditTextElement(textElement.Id);
        StateHasChanged();
    }

    private async Task EditTextElement(Guid elementId)
    {
        var element = canvasElements.FirstOrDefault(e => e.Id == elementId);
        if (element != null && element.IsTextElement)
        {
            editingElementId = elementId;
            editingText = element.TextContent ?? "";
            isEditingText = true;
            StateHasChanged();

            // Focus on textarea after render
            await Task.Delay(50);
            await textareaRef.FocusAsync();
        }
    }

    private void SaveTextEdit()
    {
        if (editingElementId.HasValue)
        {
            var element = canvasElements.FirstOrDefault(e => e.Id == editingElementId.Value);
            if (element != null)
            {
                element.TextContent = editingText;

                // Remove element if text is empty
                if (string.IsNullOrWhiteSpace(editingText))
                {
                    canvasElements.Remove(element);
                }
            }
        }

        // Reset editing state
        isEditingText = false;
        editingText = "";
        editingElementId = null;
        StateHasChanged();
    }

    private async Task HandleTextKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            SaveTextEdit();
        }
    }

    private void RemoveElement(Guid elementId)
    {
        var element = canvasElements.FirstOrDefault(e => e.Id == elementId);
        if (element != null)
        {
            canvasElements.Remove(element);
            StateHasChanged();
        }
    }

    private string GetComponentIcon(string? componentType)
    {
        return componentType switch
        {
            "TextInput" or "text" or "email" => "📝",
            "Checkbox" or "checkbox" => "☑️",
            "DateTime" or "date" => "📅",
            "RadioButton" or "radio" => "🔘",
            "number" => "🔢",
            "textarea" => "📄",
            "select" => "📋",
            _ => "📄"
        };
    }

    private void OnDragStart(ComponentResponseDto component)
    {
        draggedComponent = component;
    }

    private void OnDragOver()
    {
        // Allow drop
    }

    private async Task OnDrop(DragEventArgs e)
    {
        if (draggedComponent != null)
        {
            try
            {
                // Snap to grid
                var gridX = SnapToGrid(e.OffsetX);
                var gridY = SnapToGrid(e.OffsetY - 60); // Subtract header height

                var componentElement = new CanvasElement
                {
                    X = gridX,
                    Y = gridY,
                    ZIndex = ++zIndexCounter,
                    IsTextElement = false,
                    ComponentId = draggedComponent.Id,
                    ComponentType = draggedComponent.Type,
                    Label = draggedComponent.Label,
                    Required = draggedComponent.Required,
                    Properties = draggedComponent.Properties != null ?
                        new Dictionary<string, object>(draggedComponent.Properties) :
                        new Dictionary<string, object>()
                };

                canvasElements.Add(componentElement);
                draggedComponent = null;
                StateHasChanged();
            }
            catch (Exception ex)
            {
                // Fallback positioning with grid snap
                var componentElement = new CanvasElement
                {
                    X = SnapToGrid(150),
                    Y = SnapToGrid(150),
                    ZIndex = ++zIndexCounter,
                    IsTextElement = false,
                    ComponentId = draggedComponent.Id,
                    ComponentType = draggedComponent.Type,
                    Label = draggedComponent.Label,
                    Required = draggedComponent.Required,
                    Properties = draggedComponent.Properties != null ?
                        new Dictionary<string, object>(draggedComponent.Properties) :
                        new Dictionary<string, object>()
                };

                canvasElements.Add(componentElement);
                draggedComponent = null;
                StateHasChanged();
            }
        }
    }

    private void AddNewComponent()
    {
        try
        {
            newComponent = new PostComponentRequestDto
            {
                Type = "TextInput",
                Label = "New Component",
                Required = false,
                Properties = new Dictionary<string, object>()
            };
            newComponentMaxLength = 0;
            showAddComponentModal = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in AddNewComponent: {ex.Message}");
        }
    }

    private void CloseAddComponentModal()
    {
        try
        {
            showAddComponentModal = false;
            newComponent = new PostComponentRequestDto();
            newComponentMaxLength = 0;
            StateHasChanged();
        }



        catch (Exception ex)
        {
            Console.WriteLine($"Error in CloseAddComponentModal: {ex.Message}");
        }
    }

    private async Task SaveNewComponent()
    {
        if (string.IsNullOrWhiteSpace(newComponent.Label))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please enter a component label");
            return;
        }

        try
        {
            if (newComponent.Type == "TextInput" && newComponentMaxLength > 0)
            {
                newComponent.Properties ??= new Dictionary<string, object>();
                newComponent.Properties["MaxLength"] = newComponentMaxLength;
            }

            var result = await ComponentService.PostComponentAsync(newComponent);
            if (result != null)
            {
                availableComponents.Add(result);
                CloseAddComponentModal();
                StateHasChanged();
                await JSRuntime.InvokeVoidAsync("alert", "Component created successfully!");
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "Error creating component");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error: {ex.Message}");
        }
    }
    private async Task SaveTemplate()
    {
        if (string.IsNullOrWhiteSpace(templateName))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please enter a template name");
            return;
        }

        if (!canvasElements.Any())
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please add at least one element to the form");
            return;
        }

        isSaving = true;
        try
        {
            if (ShouldSaveToDatabase)
            {
                // Salvează în baza de date (logica originală)
                await SaveTemplateFromLocalStorageToDatabase();
            }
            else
            {
                // Salvează în localStorage
                await SaveToLocalStorage();

                // Trigger event cu un temporary ID pentru navigare
                var tempId = Guid.NewGuid();
                await OnTemplateSaved.InvokeAsync((tempId, templateName));

                await JSRuntime.InvokeVoidAsync("alert", "Template saved locally! Continue to build your workflow.");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    // Metodă pentru salvare în localStorage
    private async Task SaveToLocalStorage()
    {
        var templateData = new
        {
            TemplateName = templateName,
            CanvasElements = canvasElements.Select(e => new
            {
                Id = e.Id,
                X = e.X,
                Y = e.Y,
                ZIndex = e.ZIndex,
                IsTextElement = e.IsTextElement,
                TextContent = e.TextContent,
                ComponentId = e.ComponentId,
                ComponentType = e.ComponentType,
                Label = e.Label,
                Required = e.Required??false,
                Properties = e.Properties
            }).ToList(),
            ZIndexCounter = zIndexCounter
        };

        var jsonString = System.Text.Json.JsonSerializer.Serialize(templateData);
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "formTemplate", jsonString);
    }

    // Metodă pentru încărcare din localStorage
    public async Task LoadFromLocalStorage()
    {
        try
        {
            var jsonString = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "formTemplate");

            if (!string.IsNullOrEmpty(jsonString))
            {
                using var document = System.Text.Json.JsonDocument.Parse(jsonString);
                var root = document.RootElement;

                // Restore template name
                templateName = root.GetProperty("TemplateName").GetString() ?? "";

                // Restore canvas elements
                canvasElements.Clear();
                var elementsJson = root.GetProperty("CanvasElements");

                foreach (var elementJson in elementsJson.EnumerateArray())
                {
                    var element = new CanvasElement
                    {
                        Id = Guid.Parse(elementJson.GetProperty("Id").GetString()!),
                        X = elementJson.GetProperty("X").GetDouble(),
                        Y = elementJson.GetProperty("Y").GetDouble(),
                        ZIndex = elementJson.GetProperty("ZIndex").GetInt32(),
                        IsTextElement = elementJson.GetProperty("IsTextElement").GetBoolean()
                    };

                    // Handle optional properties
                    if (elementJson.TryGetProperty("TextContent", out var textContentProperty))
                    {
                        element.TextContent = textContentProperty.GetString();
                    }

                    if (elementJson.TryGetProperty("ComponentType", out var compTypeProperty))
                    {
                        element.ComponentType = compTypeProperty.GetString();
                    }

                    if (elementJson.TryGetProperty("Label", out var labelProperty))
                    {
                        element.Label = labelProperty.GetString();
                    }

                    if (elementJson.TryGetProperty("Required", out var requiredProperty))
                    {
                        if (requiredProperty.ValueKind == JsonValueKind.True || requiredProperty.ValueKind == JsonValueKind.False)
                            element.Required = requiredProperty.GetBoolean();
                        else
                            element.Required = false;
                    }


                    if (elementJson.TryGetProperty("ComponentId", out var compIdProperty) &&
                        !compIdProperty.ValueKind.Equals(System.Text.Json.JsonValueKind.Null))
                    {
                        element.ComponentId = Guid.Parse(compIdProperty.GetString()!);
                    }

                    if (elementJson.TryGetProperty("Properties", out var propsProperty) &&
                        !propsProperty.ValueKind.Equals(System.Text.Json.JsonValueKind.Null))
                    {
                        element.Properties = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(propsProperty.GetRawText());
                    }

                    canvasElements.Add(element);
                }

                // Restore z-index counter
                if (root.TryGetProperty("ZIndexCounter", out var zCounterProperty))
                {
                    zIndexCounter = zCounterProperty.GetInt32();
                }

                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error loading template: {ex.Message}");
        }
    }



    public async Task<(Guid Id, string Name)?> SaveTemplateFromLocalStorageToDatabase(Guid? flowId = null)
    {
        try
        {
            // 1. CITEȘTE din localStorage (NU din canvasElements!)
            var jsonString = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "formTemplate");
            Console.WriteLine($"JSON from localStorage: {jsonString}");

            if (string.IsNullOrEmpty(jsonString))
            {
                await JSRuntime.InvokeVoidAsync("alert", "No template found in localStorage");
                return null;
            }

            // 2. PARSEAZĂ localStorage data
            using var document = System.Text.Json.JsonDocument.Parse(jsonString);
            var root = document.RootElement;

            var storedTemplateName = root.GetProperty("TemplateName").GetString(); // DIN localStorage
            var elementsJson = root.GetProperty("CanvasElements");

            // 3. Convertește elementele din localStorage în CanvasElement objects
            var storedElements = new List<CanvasElement>();

            foreach (var elementJson in elementsJson.EnumerateArray())
            {
                var element = new CanvasElement
                {
                    Id = Guid.Parse(elementJson.GetProperty("Id").GetString()!),
                    X = elementJson.GetProperty("X").GetDouble(),
                    Y = elementJson.GetProperty("Y").GetDouble(),
                    ZIndex = elementJson.GetProperty("ZIndex").GetInt32(),
                    IsTextElement = elementJson.GetProperty("IsTextElement").GetBoolean()
                };

                // Handle optional properties
                if (elementJson.TryGetProperty("TextContent", out var textContent))
                    element.TextContent = textContent.GetString();
                if (elementJson.TryGetProperty("ComponentType", out var compType))
                    element.ComponentType = compType.GetString();
                if (elementJson.TryGetProperty("Label", out var label))
                    element.Label = label.GetString();
                if (elementJson.TryGetProperty("Required", out var required))
                    element.Required = required.GetBoolean();
                if (elementJson.TryGetProperty("ComponentId", out var compId) &&
                    !compId.ValueKind.Equals(System.Text.Json.JsonValueKind.Null))
                    element.ComponentId = Guid.Parse(compId.GetString()!);
                if (elementJson.TryGetProperty("Properties", out var props) &&
                    !props.ValueKind.Equals(System.Text.Json.JsonValueKind.Null))
                    element.Properties = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(props.GetRawText());

                storedElements.Add(element);
            }

            // 4. ACUM folosește datele din localStorage (NU din UI!)
            var componentIds = new List<Guid>();

            // Create components folosind storedElements (NU canvasElements!)
            foreach (var element in storedElements.Where(e => !e.IsTextElement))
            {
                if (element.ComponentId.HasValue)
                {
                    componentIds.Add(element.ComponentId.Value);
                }
                else
                {
                    var newComponentRequest = new PostComponentRequestDto
                    {
                        Type = element.ComponentType ?? "TextInput",
                        Label = element.Label ?? "Unnamed Component",
                        Required = element.Required ?? false,
                        Properties = element.Properties ?? new Dictionary<string, object>()
                    };

                    var componentResponse = await ComponentService.PostComponentAsync(newComponentRequest);
                    if (componentResponse != null)
                    {
                        componentIds.Add(componentResponse.Id);
                        element.ComponentId = componentResponse.Id;
                    }
                }
            }



            // 5. Create JSON content folosind storedElements (NU canvasElements!)
            var templateContent = System.Text.Json.JsonSerializer.Serialize(new
            {
                Layout = "FreeCanvas",
                Elements = storedElements.Select(e => new
                {
                    Id = e.Id,
                    X = e.X,
                    Y = e.Y,
                    ZIndex = e.ZIndex,
                    IsTextElement = e.IsTextElement,
                    TextContent = e.TextContent,
                    ComponentId = e.ComponentId,
                    ComponentType = e.ComponentType,
                    Label = e.Label,
                    Required = e.Required,
                    Properties = e.Properties
                }).ToList()
            });

            var formTemplateRequest = new PostFormTemplateRequestDto
            {
                Name = storedTemplateName ?? "Untitled Template", // DIN localStorage (NU templateName!)
                Content = templateContent,
                FlowId = flowId,
                Components = componentIds
            };

            var templateResponse = await FormTemplateService.PostFormTemplateAsync(formTemplateRequest);
            if (templateResponse != null)
            {
                // Clear localStorage după salvare
                await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "formTemplate");

                canvasElements.Clear();
                templateName = "";
                zIndexCounter = 1;
                StateHasChanged();
                return (templateResponse.Id, templateResponse.Name);
            }

            return null;
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("alert", $"Error saving template: {ex.Message}");
            return null;
        }
    }






}
